
Логика решения
Для решения задачи раскраски графа (Graph Coloring Problem - GCP) методом Табу-поиска мы будем использовать следующий подход:

1.	Цель: Найти раскраску с $k$ цветами, где количество конфликтов (ребер, соединяющих вершины одного цвета) равно 0.
2.	Стратегия:
o	Мы начинаем с некоторого количества цветов $k$.
o	Запускаем Табу-поиск, который пытается минимизировать функцию приспособленности (количество конфликтов).
o	Если алгоритм находит решение с 0 конфликтов, мы пробуем уменьшить количество цветов ($k - 1$) и запускаем поиск снова.
o	Если за 500 итераций решение не найдено, мы останавливаемся и возвращаем лучший найденный результат.
3.	Табу-лист: Когда мы меняем цвет вершины $V$ с цвета $A$ на $B$, мы добавляем в Табу-лист запись $(V, A)$. Это запрещает возвращать вершине $V$ цвет $A$ в течение следующих 10 итераций.

Пояснение результатов работы программы

1.	Инициализация: Создается граф из 12 вершин.
2.	Цикл уменьшения цветов ($k$):
o	Алгоритм сначала пробует раскрасить граф в 11 цветов, затем в 10, 9 и так далее.
o	Для каждого $k$ запускается цикл из 500 итераций.
3.	Поиск соседа: На каждом шаге алгоритм проверяет возможные изменения цвета для вершин. Он выбирает то изменение, которое сильнее всего уменьшает количество конфликтов.
4.	Табу-лист: Если мы изменили цвет вершины 3 с "Красного" на "Синий", пара (Вершина 3, Красный) попадает в Табу-лист. Это значит, что в ближайшие 10 ходов мы не можем вернуть вершине 3 красный цвет. Это заставляет алгоритм искать новые пути, а не ходить по кругу.
5.	Вывод: В конце скрипт выводит минимальное $k$, при котором удалось достичь 0 конфликтов, и списки вершин для каждого цвета.

Пример ожидаемого вывода

...
Попытка найти раскраску для 4 цветов...
  -> Успех! Найдено решение без конфликтов на итерации 32
Попытка найти раскраску для 3 цветов...
  -> Не удалось найти решение для 3 цветов за 500 итераций.
------------------------------
ФИНАЛЬНЫЙ РЕЗУЛЬТАТ:
Минимальное количество цветов: 4
Распределение цветов по вершинам:
  Цвет 0: Вершины [0, 2, 5, 11]
  Цвет 1: Вершины [1, 4, 8]
  Цвет 2: Вершины [3, 6, 9]
  Цвет 3: Вершины [7, 10]

Временная сложность 

1. Сложность одной итерации поиска

Внутри одной итерации (while iter_count < max_iterations) происходит поиск лучшего соседа.
1.	Перебор вершин: Мы проходим по всем вершинам графа.
o	Сложность: $O(V)$
2.	Перебор цветов: Для каждой вершины мы пробуем сменить её цвет на любой другой из доступных $K$.
o	Сложность: $O(K)$ (в худшем случае $K \approx V$)
o	Итого вариантов хода: $O(V \cdot K) \approx O(V^2)$.
3.	Оценка решения (функция приспособленности):
В представленном коде используется функция _count_conflicts, которая проверяет всю матрицу смежности (или список ребер).
o	Код: for i in range(N): for j in range(i+1, N): ...
o	Сложность: $O(V^2)$ (или $O(E)$).
Итоговая сложность одного шага (поиска соседа):
$$O(\text{вершины} \times \text{цвета} \times \text{проверка конфликтов})$$
$$O(V \cdot V \cdot V^2) = O(V^4)$$

2. Общая сложность алгоритма
Алгоритм выполняется $I$ раз для каждого количества цветов (в худшем случае мы пробуем уменьшать цвета от $V$ до 1).
$$T_{total} = O(\text{число попыток } K) \cdot I \cdot O(V^4)$$
Если считать, что мы проверяем небольшое количество вариантов $K$ (или это константа относительно $V$ в рамках поиска хроматического числа), то сложность фиксируется на:
$$O(I \cdot V^4)$$
Для данной задачи ($V=12, I=500$):
Это примерно $500 \cdot 12^4 \approx 10^7$ операций. Для современного процессора это доли секунды, поэтому "наивная" реализация (полный пересчет конфликтов) здесь допустима.

Контрольный вопрос (вариант 18): Почему мы используем приближенные алгоритмы для NP-сложных задач? 

Суть в физической невозможности найти точное решение за разумное время.
1.	Комбинаторный взрыв: В NP-сложных задачах количество вариантов растет экспоненциально. Добавление всего пары элементов может увеличить время расчета в тысячи раз.
2.	Время: Для больших данных (например, 100 вершин) поиск идеального решения займет миллиарды лет даже на суперкомпьютерах.
3.	Сделка: Мы осознанно жертвуем точностью (соглашаемся на решение, которое на 1-5% хуже идеала), чтобы выиграть время (получить ответ за секунды, а не за века).
Кратко: Лучше «хорошее» решение сегодня, чем «идеальное» через миллион лет.

