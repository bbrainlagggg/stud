Алгоритмы и структуры данных
Сортировки и поиск
Сортировки
1. Сортировка выбором (Selection Sort)

Суть метода: На каждом шаге алгоритм находит минимальный элемент из неотсортированной части массива и перемещает его на начало этой части.

Пошаговая логика:

Считаем первый элемент текущим минимальным.

Проходим оставшуюся часть массива, чтобы найти настоящий минимальный элемент.

Если встречаем элемент меньше текущего минимума, запоминаем его позицию.

После обхода неотсортированной части меняем местами найденный минимум с первым элементом этой части.

Сдвигаем границу отсортированной части на одну позицию вправо.

Повторяем шаги 1–5 для оставшейся части массива.

Сложность:

В худшем, среднем и лучшем случае: O(n²).

Пример:
Исходный массив: [64, 25, 12, 22, 11]

Шаг 1: минимальный элемент 11 меняем с 64 → [11, 25, 12, 22, 64]

Шаг 2: минимальный 12 меняем с 25 → [11, 12, 25, 22, 64]

Шаг 3: минимальный 22 меняем с 25 → [11, 12, 22, 25, 64]

Шаг 4: минимальный 25 меняем с 25 → [11, 12, 22, 25, 64]

Результат: [11, 12, 22, 25, 64]

2. Сортировка пузырьком (Bubble Sort)

Идея: Многократно просматриваем массив, сравнивая соседние элементы, и переставляем их, если порядок нарушен.

Алгоритм:

Устанавливаем флаг обмена в false.

Проходим массив от начала до конца-1.

Сравниваем текущий элемент со следующим. Если текущий больше следующего, меняем их местами и ставим флаг в true.

После каждого прохода наибольший элемент оказывается в конце массива.

Сужаем границу неотсортированной части на 1.

Повторяем шаги 2–5 до тех пор, пока за проход не произойдет ни одного обмена.

Сложность:

Лучший случай (уже отсортирован): O(n)

Средний и худший случай: O(n²)

Пример:
Исходный массив: [5, 1, 4, 2, 8]

Первый проход: [1, 4, 2, 5, 8]

Второй проход: [1, 2, 4, 5, 8]

Третий проход: [1, 2, 4, 5, 8]
Результат: [1, 2, 4, 5, 8]

3. Сортировка вставками (Insertion Sort)

Идея: Строим отсортированную часть массива, вставляя новые элементы в правильное место.

Пошагово:

Берем второй элемент массива как текущий для вставки.

Сохраняем его значение в переменной key.

Сравниваем key с элементами отсортированной части справа налево.

Сдвигаем все элементы, большие key, вправо.

Вставляем key на найденную позицию.

Переходим к следующему элементу и повторяем шаги 2–5.

Сложность:

Лучший случай (уже отсортирован): O(n)

Худший случай (обратный порядок): O(n²)

Пример:
Исходный массив: [12, 11, 13, 5, 6]

Вставка 11 → [11, 12, 13, 5, 6]

Вставка 13 → [11, 12, 13, 5, 6]

Вставка 5 → [5, 11, 12, 13, 6]

Вставка 6 → [5, 6, 11, 12, 13]

4. Сортировка слиянием (Merge Sort)

Идея: Метод «разделяй и властвуй»: делим массив на половины, рекурсивно сортируем каждую и объединяем отсортированные части.

Алгоритм:

Если массив содержит 0 или 1 элемент, он уже отсортирован.

Разделяем массив пополам.

Рекурсивно сортируем левую и правую половины.

Объединяем их в один отсортированный массив.

Сложность: O(n log n) во всех случаях.

5. Сортировка Шелла (Shell Sort)

Идея: Улучшение сортировки вставками за счет убывающих интервалов (gap).

Алгоритм:

Выбираем начальный интервал gap.

Сортируем элементы через этот интервал.

Уменьшаем интервал и повторяем сортировку.

Завершаем с gap = 1.

Сложность: зависит от выбранной последовательности интервалов:

Лучший случай: O(n log n)

Худший случай: O(n²)

6. Быстрая сортировка (Quick Sort)

Идея: «Разделяй и властвуй», выбираем опорный элемент и делим массив на части меньше и больше него.

Сложность:

Лучший/средний: O(n log n)

Худший: O(n²)

7. Пирамидальная сортировка (Heap Sort)

Идея: Использует max-кучу для извлечения наибольшего элемента.

Сложность: O(n log n)

Поиск
1. Линейный поиск

Идея: Проверяем элементы массива по очереди.
Сложность: O(n)

2. Бинарный поиск

Идея: Работает на отсортированном массиве, деля диапазон пополам.
Сложность: O(log n)

3. Интерполяционный поиск

Идея: Улучшенный бинарный поиск для равномерно распределённых данных.
Сложность:

Лучший случай: O(1)

Средний: O(log log n)

Худший: O(n)

4. Поиск Фибоначчи

Идея: Использует числа Фибоначчи для деления массива.
Сложность: O(log n)
