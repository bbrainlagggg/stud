Вариант 8. Реализуйте рекурсивную функцию для подсчета суммы элементов массива.

Как работает алгоритм — Рекурсивное суммирование массива (Recursive Array Sum).
Стратегия рекурсии предлагает решать задачу, сводя ее к той же, но меньшей по размеру задаче, пока не будет достигнут базовый случай (условие завершения).
Имеется массив (список) из $n$ элементов.
1.Базовый случай (Условие завершения): Если массив пуст (его длина $n=0$), его сумма равна 0. Рекурсия завершается.
2.Рекурсивный шаг (Сведение): Если массив не пуст, его общая сумма — это первый элемент плюс сумма оставшейся части массива (подмассива длиной $n-1$). Функция вызывает сама себя, передавая ей оставшийся подмассив.
Этот процесс повторяется: функция "снимает" по одному элементу, складывает его, и вызывает себя для остатка, пока не останется пустой массив.

Пошаговый алгоритм (на примере Python):
def sum_array_recursive(arr):
    """
    Рекурсивно вычисляет сумму элементов массива (списка).
    """
    
    # 1. Проверяем базовый случай: Пустой массив
    if not arr:
        return 0
    
    # 2. Рекурсивный шаг: 
    # Возвращаем первый элемент + сумму остатка массива
    else:
        # arr[0] - первый элемент
        # arr[1:] - срез, содержащий все элементы, кроме первого
        return arr[0] + sum_array_recursive(arr[1:])


# Пример
my_array = [10, 2, 5, 8]
result = sum_array_recursive(my_array)
print(f"Сумма элементов (рекурсивно): {result}") 

Пошаговая логика вызова для [10, 2, 5, 8]:
•	sum_array_recursive([10, 2, 5, 8]) $\rightarrow$ 10 + sum_array_recursive([2, 5, 8])
•	sum_array_recursive([2, 5, 8]) $\rightarrow$ 2 + sum_array_recursive([5, 8])
•	sum_array_recursive([5, 8]) $\rightarrow$ 5 + sum_array_recursive([8])
•	sum_array_recursive([8]) $\rightarrow$ 8 + sum_array_recursive([])
•	sum_array_recursive([]) $\rightarrow$ 0 (Базовый случай)
Обратный ход: $10 + 2 + 5 + 8 + 0 = 25$.

Временная сложность: $O(n)$
Трудоёмкость алгоритма рекурсивного суммирования массива линейна относительно количества элементов $n$.
•	На каждом рекурсивном шаге выполняется постоянное количество операций ($O(1)$): обращение к первому элементу, сложение и создание нового среза (подмассива).
•	Общее количество рекурсивных вызовов равно $n$ (по одному на каждый элемент).
$$T(n) = T(n-1) + c \rightarrow T(n) = \Theta(n)$$
Памятью алгоритм пользуется дополнительной, в основном за счет стека рекурсии, глубина которого равна $n$. В языках, где создание среза arr[1:] влечет за собой копирование данных (как в Python), на каждой итерации может потребоваться дополнительная память $O(n)$, что делает общую сложность по памяти $O(n^2)$. Однако, если передавать в функцию только индексы (начало и конец диапазона), сложность по памяти для данных будет $O(1)$, а по стеку рекурсии — $O(n)$.



6. В чем суть алгоритма backtracking?

Суть алгоритма Backtracking (Возвращение с помощью обхода)
Backtracking — это мощный алгоритм для поиска решений, который представляет собой усовершенствованный поиск в глубину (DFS) по пространству состояний задачи. Его основная идея заключается в последовательном построении решения с возможностью отката на предыдущий шаг, если текущий путь оказывается бесперспективным.

1. Основные этапы работы
Алгоритм работает в три ключевых цикла:

Разделяй (Выбор): На текущем шаге алгоритм выбирает один из доступных вариантов и добавляет его к частичному решению-кандидату. Решение строится поэтапно, шаг за шагом.

Проверяй (Отсечение): После каждого выбора выполняется проверка, соблюдаются ли ограничения задачи. Если текущее частичное решение нарушает правила или очевидно не ведет к полному решению, весь дальнейший путь отбрасывается (отсекается). Это критически важный шаг для сокращения области поиска.

Властвуй (Откат/Backtrack): Если текущий путь зашел в тупик (нет доступных вариантов продолжения) или был отброшен при проверке, алгоритм выполняет откат на предыдущий шаг. Он отменяет сделанный выбор и пробует следующий доступный вариант, который еще не был рассмотрен.

Этот процесс продолжается до тех пор, пока не будет найдено одно или все возможные полные решения.

2. Примеры применения
Backtracking часто используется для решения комбинаторных задач и головоломок, где решение состоит из серии последовательных выборов, например:

Нахождение всех возможных перестановок множества элементов.

Задача о восьми ферзях: Размещение ферзей на шахматной доске так, чтобы ни один из них не атаковал другого. Если ферзь, поставленный в текущий столбец, находится под боем, алгоритм снимает его и пробует другую строку (откат).

Решение судоку: Заполнение пустой клетки числом. Если число нарушает правила, оно стирается, и пробуется следующее (откат).

Поиск гамильтонова цикла в графе или поиск выхода из лабиринта.

3. Трудоемкость
Несмотря на то, что backtracking фактически исследует дерево поиска, благодаря шагу отсечения (проверки ограничений) он обычно работает гораздо быстрее, чем полный перебор всех возможных комбинаций. Однако в худшем случае (когда отсечение неэффективно) его временная сложность может оставаться экспоненциальной.